#
#
#

#
#
die() {
	echo "$*" >&2
	exit 1
}

#
#
builder_brute_find() {
	local op="$1" cue="$2"

	while [ "$PWD" != / ]; do

		if [ $op "$PWD/$cue" ]; then
			echo "$PWD"
			break
		fi

		cd ..
	done
}

#
#
builder_find_workspace() {
	local ws= prev="$PWD" check="$1"

	# any .repo workspace wins
	ws="$(builder_brute_find -d .repo)"
	if [ ! -d "$ws" ]; then
		while true; do
			# try .git repositories
			ws="$(git rev-parse --show-superproject-working-tree 2> /dev/null || true)"
			[ -d "$ws" ] || ws="$(git rev-parse --show-toplevel 2> /dev/null || true)"

			if [ ! -d "$ws" ]; then
				# no deeper git-root, accept what we had
				ws=
				break
			elif [ -z "$check" ]; then
				# git-root is good, unchecked
				break
			elif $check "$ws"; then
				# git-root passed the checks
				break
			elif [ "$ws" != / ]; then
				# remember this git-root, but try deeper
				prev="$ws"
				cd "$ws/.."
			else
				# can't go deeper, just take it
				break
			fi
		done
	fi

	echo "${ws:-$prev}"
}

#
#
builder_find_docker_dir() {
	local run_sh="$1" dir="$2"

	if [ -z "$dir" ]; then
		dir="$(dirname "$run_sh")"

		while [ ! -s "$dir/Dockerfile" ]; do
			if [ -L "$run_sh" ]; then
				# follow symlink
				run_sh="$(readlink "$run_sh")"

				case "$run_sh" in
				/*)	;;
				*)	run_sh="$(realpath "$dir/$run_sh")" ;;
				esac

				dir="$(dirname "$run_sh")"
			else
				die "$1: failed to detect Dockerfile"
			fi
		done

	elif [ ! -s "$dir/Dockerfile" ]; then
		die "$dir: invalid docker directory"
	fi

	echo "$dir"
}

#
builder_gen_volumes() {
	local v= x=
	for v; do
		# name to value
		eval "echo \"\${$v:-}\""
	done | sort -uV | while read x; do
		# skip empty lines
		[ -n "$x" -a '/' != "$x" ] || continue

		# create missing directories
		[ -d "$x/" ] || mkdir -p "$x"

		# prevent root-owned directories at $home_dir
		case "$x" in
		"$HOME"/*|"$HOME")
			x0="${x#$HOME}"
			mkdir -p "$home_dir$x0"
			;;
		esac

		# render -v pairs
		case "$x" in
		"$HOME")
			echo "-v \"$home_dir:$x\""
			;;
		*)
			echo "-v \"$(readlink -f "$x"):$x\""
			;;
		esac
	done | tr '\n' ' '
}

#
builder_gen_env() {
	local x= v=
	for x; do
		eval "v=\"\${$x:-}\""
		if [ -n "$v" ]; then
			echo "-e \"$x=$v\""
		fi
	done | tr '\n' ' '
}

#
#
builder_run_exec() {
	local home_dir= parent_dir=
	local WS="$1"
	shift 1

	# preserve user identity
	local USER_NAME="$(id -urn)"
	local USER_UID="$(id -ur)"
	local USER_GID="$(id -gr)"

	if [ -z "${HOME:-}" ]; then
		HOME="$(getent passwd "$USER_NAME" | cut -d: -f6)"
	fi

	# hook to extend run.sh before mounting volumes or exporting variables
	#
	if [ -d "${DOCKER_DIR:-}" -a -s "${DOCKER_DIR:-}/run-hook.in" ]; then
		. "$DOCKER_DIR/run-hook.in"
	fi

	# persistent volumes
	#
	if [ -z "${DOCKER_RUN_CACHEDIR:-}" ]; then
		DOCKER_RUN_CACHEDIR="$WS/.docker-run-cache"
	fi

	home_dir="$DOCKER_RUN_CACHEDIR/$HOME"
	parent_dir="$(dirname "$WS")"

	# add more options
	#
	# volumes -> -v
	# gen_env -> -e
	#
	eval "set -- \
		$(builder_gen_volumes ${DOCKER_RUN_VOLUMES:-} parent_dir HOME PWD WS) \
		$(builder_gen_env ${DOCKER_RUN_ENV:-}) \
		${DOCKER_EXTRA_OPTS:-} \
		\"\$@\""

	# PTRACE
	set -- \
		--cap-add SYS_PTRACE \
		--security-opt apparmor:unconfined \
		--security-opt seccomp:unconfined \
		"$@"

	# isatty()
	if [ -t 0 ]; then
		set -- -ti "$@"
	else
		set -- -i "$@"
	fi

	# and finally run within the container
	set -x
	exec docker run --rm \
		-e USER_HOME="$HOME" \
		-e USER_NAME="$USER_NAME" \
		-e USER_UID="$USER_UID" \
		-e USER_GID="$USER_GID" \
		-e CURDIR="$PWD" \
		-e WS="$WS" \
		"$@"
}
